# Copyright 2018 QuantInsti Quantitative Learnings Pvt Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Created on Wed Jan  9 10:17:29 2019

@author: prodipta
"""
from os import path as os_path
import pandas as pd
import json
#import empyrical
#import bottleneck
from blueshift.utils.decorators import singleton
from blueshift.utls.types import MaxSizedOrderedDict, NANO_SECOND
from blueshift.trades._order_types import OrderSide

class ReconciliationReport(object):
    '''
        class to persiste a reconciliation report. This starts with an
        initial snapshot of the existing account balances and positions.
        All the orders triggered by the algo is logged with (entered in)
        the blotter. When reconciliation is called, the blotter checks the
        changes (implied and actual) and saves the report.
    '''
    def __init__(self, timestamp, matched_pos, unexplained_pos, account_view,
                 matching_orders, missing_orders, extra_orders, root):
        self._timestamp = timestamp
        self._matched_pos = matched_pos
        self._unexplained_pos = unexplained_pos
        self._account_view = account_view
        self._matching_orders = matching_orders
        self._missing_orders = missing_orders
        self._extra_orders = extra_orders
        self._root = root
        
    def get_save_path(self, algo_name=None):
        algo_name = str(algo_name) if algo_name else ''
        str_ts = str(self._timestamp).replace('-','')
        str_ts = str_ts.replace(':','_').replace(' ','-')
        versioned_fname = 'reconciliation_'+ algo_name + str_ts
        versioned_fname = os_path.join(self._root, versioned_fname + ".json")
        current_fname = 'reconciliation_'+ algo_name
        current_fname = os_path.join(self._root, current_fname + ".json")
        
        return current_fname, versioned_fname
    
    def write(self, algo_name=None):
        reconciliation = assets = {}
        
        reconciliation['timestamp'] = self._last_reconciled
        
        for pos in self._matched_pos:
            reconciliation['matching_positions'][str(pos)]=\
                            self._matched_pos[pos].to_dict()
            assets.append(pos)
                            
        for pos in self._unexplained_pos:
            reconciliation['matching_positions'][str(pos)]=\
                            self._unexplained_pos[pos]
            assets.append(pos)
            
        assets = set(assets)
        for asset in assets:
            reconciliation[str(asset)]=asset.to_dict()
                            
        for i in range(len(self._matching_orders)):
            self._matching_orders[i] = self._matching_orders[i].to_dict()    
        reconciliation['matching_orders'] = self._matching_orders
        
        for i in range(len(self._missing_orders)):
            self._missing_orders[i] = self._missing_orders[i].to_dict()    
        reconciliation['missing_orders'] = self._missing_orders
        
        for i in range(len(self._extra_orders)):
            self._extra_orders[i] = self._extra_orders[i].to_dict()    
        reconciliation['extra_orders'] = self._extra_orders
        
        # save versioned snapshot
        current_fname, versioned_fname = self.get_save_path()
        with open(versioned_fname,"w") as fp:
            json.dump(reconciliation, fp)
        # overwrite the current snapshot
        with open(current_fname,"w") as fp:
            json.dump(reconciliation, fp)

@singleton
class Blotter(object):
    '''
        Blotter tracks the order generated by the algo and matches them
        from the order status received from the broker API. It also computes
        the positions that should arise out of those algo orders and matches
        against the positions from broker API. Cumulative sum of the realized
        and unrealized pnls from these positions are algo pnl. This helps us
        avoid computing algo performance solely based on account information,
        as the account can also be affected by other means (manual trades or
        capital withdrawals etc.).
    '''
    MAX_TRANSACTIONS = 50000
    
    def __init__(self, blotter_root, account_net, logger=None, 
                 alert_manager=None):
        self._orders = MaxSizedOrderedDict(max_size=self.MAX_TRANSACTIONS, 
                                           chunk_size=1)
        self.blotter_root = blotter_root
        self._last_reconciled = None
        self._last_saved = None
        self._needs_reconciliation = False
        self._logger = logger
        
        self._commisions = 0
        self._pnl = 0
        self._current_net = account_net
        self._account_view = {}
        
        if alert_manager:
            alert_manager.register_callback(self.save)
        
    def create(self, blotter_root):
        pass
    
    def reset(self):
        pass
    
    def save(self):
        pass
    
    def add_transactions(self, order_id, order, commissions):
        self._orders[order_id] = order
        self._commisions = self._commisions + commissions
        self._needs_reconciliation = True
        
    def _compute_pnl(self, open_pos, closed_pos):
        self._pnl = 0
        
        for pos in closed_pos:
            self._pnl = self._pnl + pos.pnl
        
        for key in open_pos:
            self._pnl = self._pnl + pos[key].pnl
    
    def _reconcile_orders(self, orders):
        missing_orders = extra_orders = matching_orders = []
        orders_list = list(self._orders.keys())
        
        for key in orders:
            if key in orders_list:
                matching_orders.append(orders[key])
                self._orders.pop(key)
            else:
                extra_orders.append(orders[key])
        
        missing_orders = self._orders
        self._orders = {}
        
        if missing_orders or extra_orders:
            matched = False
        else:
            matched = True
        
        return matched, matching_orders, missing_orders, extra_orders
    
    def _positions_from_orders(self, orders):
        expected_pos = {}
        
        for key in orders:
            asset = orders[key].asset
            side = 1 if orders[key].side == OrderSide.BUY else -1
            amount = orders[key].fill*side
            if asset in expected_pos:
                expected_pos[asset] = expected_pos[asset] + amount
            else:
                expected_pos[asset] = amount
                
        return expected_pos
    
    def _reconcile_positions(self, positions, expected_pos):
        unexplained_pos = matching_pos = []
        
        for asset in positions:
            amount_reported = positions[asset].quantity
            if asset in expected_pos:
                amount_expected = expected_pos[asset]
                if amount_expected == amount_reported:
                    matching_pos[asset] = positions[asset]
                else:
                    unexplained_pos[asset] = amount_reported - amount_expected
            else:
                unexplained_pos[asset] = amount_reported
                
        if unexplained_pos:
            matched = False
        else:
            matched = True
                
        return matched, matching_pos, unexplained_pos
    
    def _reconcile_account(self, account):
        net_value = (self._current_net + self._pnls)
        net_difference = account.net - net_value
        self._current_net = account.net
        
        self._account_view = {"net": account.net,
                              "cash": account.cash,
                              "margin": account.margin,
                              "net_difference": net_difference}
    
    def _reconcile(self, positions, orders, account, timestamp=None):
        order_matched, matching_orders, missing_orders, extra_orders = \
                        self._reconcile_orders(orders)
        expected_pos = self._positions_from_orders(matching_orders)
        pos_matched, matching_pos, unexplained_pos = \
                        self._reconcile_positions(positions, expected_pos)
        self._reconcile_account(account)                                                    
        self._needs_reconciliation = False
        
        if not timestamp:
            timestamp = pd.Timestamp.now().value
            timestamp = pd.Timestamp(int(timestamp/NANO_SECOND)*NANO_SECOND)
            
        self._last_reconciled = timestamp
    
    def _write_report(self, algo_name=None, timestamp=None):            
        report = ReconciliationReport(self._last_reconciled, 
                                      self._matched_pos, 
                                      self._unexplained_pos, 
                                      self._account_view,
                                      self._matching_orders, 
                                      self._missing_orders, 
                                      self._extra_orders, self._root)
        report.write()
        
        if not timestamp:
            timestamp = pd.Timestamp.now().value
            timestamp = pd.Timestamp(int(timestamp/NANO_SECOND)*NANO_SECOND)
        
        self._last_saved = timestamp
        
    def reconcile_and_save(self, positions, orders, account, 
                           algo_name=None, timestamp=None):
        self._reconcile(self, positions, orders, account, timestamp)
        self._write_report(algo_name, timestamp)
    
    
    
    
    
    