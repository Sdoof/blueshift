# Copyright 2018 QuantInsti Quantitative Learnings Pvt Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Created on Wed Jan  9 10:17:29 2019

@author: prodipta
"""
from os import path as os_path
import pandas as pd
import json
from collections import OrderedDict
#import empyrical
#import bottleneck
from blueshift.utils.decorators import singleton
from blueshift.utils.types import MaxSizedOrderedDict, NANO_SECOND
from blueshift.utils.exceptions import (InitializationError,
                                        BlueShiftException,
                                        ValidationError,
                                        ExceptionHandling,
                                        DataWriteException)
from blueshift.utils.helpers import (read_positions_from_dict, dict_diff,
                                     read_transactions_from_dict)

from blueshift.configs.defaults import (blueshift_saved_orders_path,
                                        blueshift_save_perfs_path,
                                        blueshift_saved_objs_path)

class ReconciliationReport(object):
    '''
        class to persiste a reconciliation report. This starts with an
        initial snapshot of the existing account balances and positions.
        All the orders triggered by the algo is logged with (entered in)
        the blotter. When reconciliation is called, the blotter checks the
        changes (implied and actual) and saves the report.
    '''
    def __init__(self, timestamp, matched_pos, unexplained_pos, account_view,
                 matching_orders, missing_orders, extra_orders, root):
        self._timestamp = timestamp
        self._matched_pos = matched_pos
        self._unexplained_pos = unexplained_pos
        self._account_view = account_view
        self._matching_orders = matching_orders
        self._missing_orders = missing_orders
        self._extra_orders = extra_orders
        self._root = root
        
    def get_save_path(self, algo_name=None):
        algo_name = str(algo_name) if algo_name else ''
        str_ts = str(self._timestamp).replace('-','')
        str_ts = str_ts.replace(':','_').replace(' ','-')
        versioned_fname = 'reconciliation_'+ algo_name + str_ts
        versioned_fname = os_path.join(self._root, versioned_fname + ".json")
        current_fname = 'reconciliation_'+ algo_name
        current_fname = os_path.join(self._root, current_fname + ".json")
        
        return current_fname, versioned_fname
    
    def write(self, algo_name=None):
        reconciliation = assets = {}
        
        reconciliation['timestamp'] = self._last_reconciled
        
        for pos in self._matched_pos:
            reconciliation['matching_positions'][str(pos)]=\
                            self._matched_pos[pos].to_dict()
            assets.append(pos)
                            
        for pos in self._unexplained_pos:
            reconciliation['matching_positions'][str(pos)]=\
                            self._unexplained_pos[pos]
            assets.append(pos)
            
        assets = set(assets)
        for asset in assets:
            reconciliation[str(asset)]=asset.to_dict()
                            
        for i in range(len(self._matching_orders)):
            self._matching_orders[i] = self._matching_orders[i].to_dict()    
        reconciliation['matching_orders'] = self._matching_orders
        
        for i in range(len(self._missing_orders)):
            self._missing_orders[i] = self._missing_orders[i].to_dict()    
        reconciliation['missing_orders'] = self._missing_orders
        
        for i in range(len(self._extra_orders)):
            self._extra_orders[i] = self._extra_orders[i].to_dict()    
        reconciliation['extra_orders'] = self._extra_orders
        
        # save versioned snapshot
        current_fname, versioned_fname = self.get_save_path()
        with open(versioned_fname,"w") as fp:
            json.dump(reconciliation, fp)
        # overwrite the current snapshot
        with open(current_fname,"w") as fp:
            json.dump(reconciliation, fp)

@singleton
class Blotter(object):
    '''
        Blotter tracks the order generated by the algo and matches them
        from the order status received from the broker API. It also computes
        the positions that should arise out of those algo orders and matches
        against the positions from broker API. Cumulative sum of the realized
        and unrealized pnls from these positions are algo pnl. This helps us
        avoid computing algo performance solely based on account information,
        as the account can also be affected by other means (manual trades or
        capital withdrawals etc.).
    '''
    MAX_TRANSACTIONS = 50000
    POSITIONS_FILE = 'positions.json'
    TRANSACTIONS_FILE = 'transactions.json'
    PERFORMANCE_FILE = 'performance.json'
    RISKS_FILE = 'risk_metrics.json'
    
    def __init__(self, mode, asset_finder, data_portal, broker_api,
                 blotter_root=None, account_net=None, 
                 starting_positions={}, timestamp=None, alert_manager=None):
        # initialize the start positions and historical records of 
        # transactions. If a start position is suppplied, that will 
        # overwrite the saved positions.
        self._blotter_root = blotter_root if blotter_root is not None \
                                else blueshift_saved_orders_path()
        self._mode = mode
        self._asset_finder = asset_finder
        self._data_portal = data_portal
        self._broker = broker_api
        self._txn_fname = os_path.expanduser(os_path.realpath(
                os_path.join(self._blotter_root,self.TRANSACTIONS_FILE)))
        self._pos_fname = os_path.expanduser(os_path.realpath(
                os_path.join(self._blotter_root,self.POSITIONS_FILE)))
        
        self.reset(timestamp, account_net, starting_positions)
        
        if alert_manager:
            alert_manager.register_callback(self.save)
        
    
    def reset(self, timestamp, account_net=None, starting_positions={}):
        self._transactions = MaxSizedOrderedDict(
                    max_size=self.MAX_TRANSACTIONS, chunk_size=1)
        self._current_pos = {}
        self._unprocessed_orders = {}
        self._known_orders = set()
        
        self._commisions = 0
        self._trading_charges = 0
        self._pnl = 0
        self._current_net = 0
        self._account_view = {}
        
        self._last_reconciled = None
        self._last_saved = None
        self._needs_reconciliation = False    
        
        self._init_positions_transactions(starting_positions)
        self._current_date = pd.Timestamp(
                timestamp.date()) if timestamp else pd.Timestamp(
                        pd.Timestamp.now().date())
    
    def _init_positions_transactions(self, positions):
        txns, pos = self._read_positions_transactions()
        if positions:
            positions = {**pos, **positions}
        
        self._transactions = txns
        self._current_pos = positions
            
    def _read_positions_transactions(self):        
        positions = {}
        transactions = MaxSizedOrderedDict(
                max_size=self.MAX_TRANSACTIONS, chunk_size=1)
        
        if os_path.exists(self._pos_fname):
            # expect jsonified data of positions keyed to assets.
            try:
                with open(self._pos_fname) as fp:
                    positions_dict = dict(json.load(fp))
                positions = read_positions_from_dict(
                        positions_dict, self._asset_finder)
            except (TypeError, KeyError, BlueShiftException):
                raise InitializationError(msg="illegal positions data.")
                
        if os_path.exists(self._txn_fname):
            # expected transactions keyed to date-time
            try:
                with open(self._txn_fname) as fp:
                    txns_dict = dict(json.load(fp))
                txns = read_transactions_from_dict(
                        txns_dict, self._asset_finder, pd.Timestamp)
                
                transactions = MaxSizedOrderedDict(
                        txns, max_size=self.MAX_TRANSACTIONS, chunk_size=1)
                
            except (TypeError, KeyError, BlueShiftException):
                raise InitializationError(msg="illegal transactions data.")
                
        return transactions, positions
    
    def _save_position_transactions(self, write_version=True):
        pos_write = {}
        try:
            for pos in self._current_pos:
                pos_write[pos.symbol] = self._current_pos[pos].to_json()
        except (TypeError, KeyError, BlueShiftException):
            raise ValidationError(msg="corrupt positions data in blotter.")
            
        txns_write = OrderedDict()
        try:
            for ts in self._transactions:
                txns = self._transactions[ts]
                txns_list = []
                for txn in txns:
                    txns_list.append(txn.to_json())
                txns_write[str(ts)] = txns_list
        except (TypeError, KeyError, BlueShiftException) as e:
            raise e
            msg = "corrupt transactions data in blotter."
            handling = ExceptionHandling.WARN
            raise ValidationError(msg=msg, handling=handling)
            
        try:
            if pos_write:
                with open(self._pos_fname, 'w') as fp:
                    json.load(pos_write, fp)
            
            if txns_write:
                with open(self._txn_fname, 'w') as fp:
                    json.load(txns_write, fp)
        except (TypeError, OSError):
            msg = f"failed to write blotter data to {pos_write}"
            handling = ExceptionHandling.WARN
            raise DataWriteException(msg=msg, handling=handling)
    
    def save(self):
        account = self._broker.account
        positions = self._broker.positions
        orders = self._broker.orders
        
        if self._needs_reconciliation:
            self._reconcile(positions, orders, account)
        self._save_position_transactions()
    
    def add_transactions(self, order_id, order, fees, charges):
        """ add entry to blotter to be verified"""
        self._unprocessed_orders[order_id] = order
        self._known_orders.add(order_id)
        self._commisions = self._commisions + fees
        self._trading_charges = self._trading_charges + charges
        self._needs_reconciliation = True
    
    def _reconcile_orders(self, orders):
        """
            process the un-processed orders list. If missing order add it
            back to the un-processed list to check in the next run.
        """
        missing_orders = extra_orders = []
        unprocessed_orders = list(self._unprocessed_orders.keys())
        
        for order_id in unprocessed_orders:
            if order_id in orders:
                order = orders[order_id]
                order_list = self._transactions.get(order.timestamp,[])
                self._transactions[order.timestamp] = order_list.append(order)
                if not order.is_open():
                    self._unprocessed_orders.pop(order_id)
            else:
                missing_orders.append[order]
        
        for key in orders:
            if key not in self._known_orders:
                extra_orders.append(orders[key])
        
        if missing_orders or extra_orders:
            matched = False
        else:
            matched = True
        
        return matched, missing_orders, extra_orders
    
    def _positions_from_orders(self, orders):
        expected_pos = {}
        
        for key in orders:
            order = orders[key]
            asset = order.asset
            side = 1 if order.is_buy() else -1
            amount = order.filled*side
            if asset in expected_pos:
                expected_pos[asset] = expected_pos[asset] + amount
            else:
                expected_pos[asset] = amount
                
        return expected_pos
    
    def _reconcile_positions(self, positions, expected_pos):
        unexplained_pos = dict_diff(expected_pos, positions)
        if unexplained_pos:
            matched = False
        else:
            matched = True
        
        return matched, expected_pos, unexplained_pos
    
    def _reconcile_account(self, account):
        net_value = (self._current_net + self._pnl)
        net_difference = account['net'] - net_value
        self._current_net = account['net']
        
        self._account_view = {"net": account['net'],
                              "cash": account['cash'],
                              "margin": account['margin'],
                              "net_difference": net_difference}
    
    def _reconcile(self, positions, orders, account, timestamp=None):
        order_matched, missing_orders, extra_orders = \
                        self._reconcile_orders(orders)
        expected_pos = self._positions_from_orders(self._transactions)
        pos_matched, matching_pos, unexplained_pos = \
                        self._reconcile_positions(positions, expected_pos)
        self._reconcile_account(account)                                                    
        self._needs_reconciliation = False
        
        if not timestamp:
            timestamp = pd.Timestamp.now().value
            timestamp = pd.Timestamp(int(timestamp/NANO_SECOND)*NANO_SECOND)
            
        self._last_reconciled = timestamp
    
    def _write_report(self, algo_name=None, timestamp=None):            
        report = ReconciliationReport(self._last_reconciled, 
                                      self._matched_pos, 
                                      self._unexplained_pos, 
                                      self._account_view,
                                      self._matching_orders, 
                                      self._missing_orders, 
                                      self._extra_orders, self._root)
        report.write()
        
        if not timestamp:
            timestamp = pd.Timestamp.now().value
            timestamp = pd.Timestamp(int(timestamp/NANO_SECOND)*NANO_SECOND)
        
        self._last_saved = timestamp
        
    def reconcile_and_save(self, positions, orders, account, 
                           algo_name=None, timestamp=None):
        self._reconcile(self, positions, orders, account, timestamp)
        self._write_report(algo_name, timestamp)
    
    
    def _compute_pnl(self, open_pos, closed_pos):
        self._pnl = 0
        
        for pos in closed_pos:
            self._pnl = self._pnl + pos.pnl
        
        for key in open_pos:
            self._pnl = self._pnl + pos[key].pnl
    
    
    